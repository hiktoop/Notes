# 局部性和快速文件系统

早期的 unix 文件系统都是这种格式的：

| SuperBlock | inodes | data |
| ---------- | ------ | ---- |

这样的结构并不能有很好的性能：

- inode 距 data 远，寻道时间长

- 极易造成碎片化(磁盘整理工具要解决的)

## FFS

FFS 诣在让文件系统的结构和分配策略具有“磁盘意识”，从而提升性能

首先将磁盘划分一些分组，称为柱面组(ext 称之为块组)，每个组的结构如下：

| SuperBlock | inodeBitmap | dataBitmap | inodes | data |
| ---------- | ----------- | ---------- | ------ | ---- |

位图是管理文件系统的绝佳方法，因为很容易找到大块的可用空间并将其分配给文件，这能很好的应对碎片问题

> 创建一个文件，inodeBitmap，inode，data 和 dataBitmap 都要写入磁盘(至少四次！)，再次之外还要更新文件的层次结构，父目录的相关信息。效率不是很低吗？---写入可以留在缓存中的，看看 xv6 的相应代码吧

### 策略：如何分配文件和目录

> 相关的东西放在一起

FFS 使用如下的策略指导文件的分配：

1. 对于目录
   
   - 找到分配数量少的柱面组(跨组平衡目录)和大量的自由 inode (随后能分配一堆文件)，并将目录数量和 inode 放在该分组

2. 对于文件
   
   - 确保将文件的数据块与其 inode 分配到相同的组
   
   - 将位于同一目录中的所有文件，放在所在目录的柱面组中

### 大文件例外

对于大块，文件系统并不会将它们放在相同的块组中，而是每个块组放置文件的一部分，因为对于大块，我们的大部分时间还是花在了磁盘传输数据上了，所以寻道时间显得不那么关键

### 其他

#### 小文件

文件块太小会影响传输速率，却浪费空间，而太大又有相反的影响，如何解决？ FFS 引入了子块的概念，对于小文件，给它们分配子块，等到文件增长到 4KB 的时候再将文件复制到 4KB 的块中并释放子块。

但是这样又多出了额外的 I/O ，因此 FFS 通过修改 libc 库来避免这种现象，通过缓冲写入，然后以 4KB 块的形式发送到文件系统，从而在大部分时候避免子块的情况

#### 磁盘布局优化

我们知道磁盘读取一块后不能马上读取下一块，但是这样就不能读取连续的块了， FFS 使用交错的布局解决了这个问题：

![](../../iamge/ostep/Screenshot%20from%202023-09-19%2016-55-58.png)

这种优化是有效的，但是效率也不高(50%)，好在现代磁盘更加智能，能在内部读取整个磁道并将其缓冲在内部磁盘缓冲中供文件系统使用

#### 增加文件名长度

#### 引入软链接

硬链接的局限在于不能指向目录(造成循环)，符号链接允许用户为系统的任何文件或目录创建别名

#### 原子 rename 操作

#### 总结

从这些小优化和功能，我们可以看出，可用性和深层的创新同样重要

# 
