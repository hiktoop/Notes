# 并发回顾

同时获得**好的并行性能、并发时的正确与可理解代码**对于内核设计是极为重要的。简单的使用锁是确保正确性的最好途径，但是那不总是可行的。本章集中于介绍 xv6 是如何困难的使用锁的，并介绍 xv6 在何时使用**类锁技术**。

## 锁的模式

缓存是一个挑战，比如文件系统的块缓存把硬盘的数据复制 N 块到内存。每个块（封装成 buf 结构体）在缓存中最多只有一个副本是极为重要的；并且 buf 中的锁确保每个时刻只有一个进程使用这块缓存。然而面对**需要的块不在缓存而又同时有两个进程想使用它**这种情况又如何应对？

要使用的块尚不存在就更不要提锁了，xv6 通过对缓存集合加上一个整体的锁来解决这个问题。在检查某个块是否在缓存或者更改缓存集合之前都需要持有整体锁，等找到指定的块时获取对应的锁再释放整体的锁。这是一种通用模式：**整体一个锁，再给每个个体一个锁**。

通常一个函数获取了锁就要释放它，但是更精确的表述是**在原子性操作之前获取锁，并在结束时释放锁**，所以当这一系列操作延迟到另一个函数或者不同的线程，甚至是不同的 CPU, 锁的释放也需要如故进行。例如 proc.c 里的 yield 函数，获取了锁，却在 scheduler 线程里释放锁。再比如 fs.c 中的 ilock，它会在读磁盘的时候进入睡眠，再一次醒来时可能就是在不同的 CPU 里，这意味着这个锁会在不同的 CPU 里被释放。

释放一个内嵌锁的结构是需要仔细考虑的，因为持有锁并不能保证释放锁后不会出现问题。当其他线程在等待持有这个锁的时候，释放结构意味着同时释放了锁，这将造成那个等待锁的线程出错。一个解决办法是跟踪有多少个线程使用了这个结构，只有当使用量为零时才能释放这个结构。

## 类锁的模式

xv6 的许多地方使用**引用计数**或一个**标志位**来表示一个结构被使用并且不能被释放和重用。例如进程的状态；文件、inode 和 buf 的引用计数。每种情况都使用锁保护状态或引用计数，后者避免结构被过早的释放。

文件系统的 inode 结构使用引用计数作为共享锁以使多进程持有它，这防止了使用普通锁而造成的死锁问题。举个例子， fs.c 中的 namex 函数锁住每个目录名



## 无锁

## 并行

## 练习

1. 修改 xv6 的 pipe 实现，使得能够在不同的 CPU 上进行并行的读写

2. 修改 xv6 的 scheduler 函数，使得不同 CPU 在找可运行进程时的锁冲突更少

3. 消除 fork 里的一些序列化



## 总结

本书通过一行一行的学习 xv6 系统来介绍了操作系统的主要思想。一些代码体现了这些思想的本质（上下文切换，用户内核边界，锁，等）。另外一些代码说明了如何实现特定的操作系统并通过不同的方式简单的完成（更好的调度算法，更好的磁盘结构以表示文件，更好的日志以允许并发交换，等）。所有这些思想被体现在了一个极其成功的系统调用接口： Unix 接口
