# 静态链接

如何将两个目标文件链接成可执行文件？这个过程发生了什么？

## 空间与地址分配

两步链接(相似段合并)：

1. 空间与地址分配，扫描所有输入目标文件
   
   1. 获取段长、属性和位置信息
   
   2. 将符号表的符号定义和引用统一到全局符号表
   
   3. 计算合并后的段长和位置，建立对应关系

2. 符号解析与重定位：使用上面第一步收集的信息，读取输入文件中段的数据、重定位信息，并且进行符号解析和重定位、调整代码中的地址等。

> ld 链接器默认程序入口为 `_start`，可以使用 `-e main` 指定 main 为程序入口

![](../../iamge/link_load_library/Screenshot%20from%202023-09-21%2020-38-28.png)

## 符号解析和重定位

- 重定位将引用符号的地址重定位到合并后文件的正确虚拟地址

- 重定位表记录了引用符号的段偏移、类型和符号名等信息

> .text 的重定位表为 .rel.text，其他类似
> 
> 使用 `objdump -r` 查看目标文件的重定位表内容(也叫重定位入口)

- 符号解析即时能在全局符号表中找到符号引用相应的定义找不到则会报符号未定义错误

- 指令修正方式依据不同处理器而不同，一般分为绝对寻址修正和相对寻址修正

## COMMON 块

弱符号的类型为 shn_common 

## C++ 相关问题

### 消除代码重复

C++ 编译器在很多时候会生成重复代码，比如不同模块使用相同的模板、外部内联函数、虚函数表和构造函数等，都会在不同目标文件内形成相同的内容，使得

- 浪费空间

- 地址容易出错(指向同一个函数的指针不同)

- 指令运行效率低(同一指令多个副本)

普遍的解决方式：

将每个模板(其他类比相似)的实例代码都单独的存放在一个段里面，每个段只包含一个模板实例。最终链接的时候相同的段合并，GCC 称之为 Link Once。这个方法也存在一些问题，比如不同编译单元使用了不同的编译器，就不同对多个副本进行选择了。

### 全局构造与析构

main 函数被调用之前要初始化进程的执行环境，比如堆分配初始化、线程子系统等，C++ 的全局构造函数就是在这个过程中执行的，析构函数是在 main 结束之后执行的。

Linux 系统下一般程序的入口是 `_start`，这是 Linux 系统库 (Glibc) 的一部分。程序初始化过程完成后会调用 main 函数来执行程序主体，执行完后返回初始化部分进行一些清理工作然后结束进程。

ELF 文件定义的特殊的段：

- .init：保存了构成进程的初始化代码的可执行指令

- fini：保存着进程终止代码的指令

### C++ 与 ABI

ABI：符号修饰标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容。

- API：源代码级别

- ABI：二进制层面

各硬件平台、编程语言、编译器、链接器和操作系统之间的 ABI 不兼容是 二进制级别难以重用最大的问题

C 语言对 ABI 的相关影响因素：

- 内置类型的大小和在存储器中的放置方式

- 组合类型的存储方式和内存布局

- 外部符号与用户定义的符号之间的命名规则和解析方式

- 函数调用方式

- 堆栈分布

- 寄存器使用约定

C++ 有更多的约束，不再赘述，细节看书 p116

## 静态链接库

一个语言的开发环境往往附带有语言库，这些库就是对操作系统 API 的包装(当然还有其他工具函数)。把这些零散的目标文件直接给用户使用会造成很大不便，所以使用 “ar“ 等压缩程序将目标文件压缩到一起，并对其进行编号和索引，一边查找和检索，就形成了 libc.a 这个静态库文件。

> 可以使用 `ar -t libc.a` 查看静态库有哪些目标文件

## 链接过程控制

三种方式链接：

- 使用命令行给链接器指定参数

- 将链接指令放到目标文件

- 使用链接控制脚本(`ld -T link.lds`)

### 脚本语法介绍

## BFD 库

使用统一接口来处理目标文件格式，GCC 的工具集都是通过 BFD 库来处理目标文件的。
